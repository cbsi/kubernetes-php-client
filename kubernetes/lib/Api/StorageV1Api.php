<?php
/**
 * StorageV1Api
 * PHP version 5
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CBSi\Kubernetes\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use CBSi\Kubernetes\ApiException;
use CBSi\Kubernetes\Configuration;
use CBSi\Kubernetes\HeaderSelector;
use CBSi\Kubernetes\ObjectSerializer;

/**
 * StorageV1Api Class Doc Comment
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class StorageV1Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createStorageClass
     *
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1StorageClass
     */
    public function createStorageClass($body, $pretty = null)
    {
        list($response) = $this->createStorageClassWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createStorageClassWithHttpInfo
     *
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1StorageClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStorageClassWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->createStorageClassRequest($body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1StorageClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createStorageClassAsync
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStorageClassAsync($body, $pretty = null)
    {
        return $this->createStorageClassAsyncWithHttpInfo($body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStorageClassAsyncWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->createStorageClassRequest($body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStorageClass'
     *
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createStorageClassRequest($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createStorageClass'
            );
        }

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionStorageClass
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionStorageClass($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionStorageClassWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionStorageClassWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionStorageClassWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionStorageClassRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionStorageClassAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionStorageClassAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionStorageClassAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionStorageClassAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionStorageClassRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionStorageClass'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionStorageClassRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStorageClass
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteStorageClass($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteStorageClassWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteStorageClassWithHttpInfo
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStorageClassWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteStorageClassRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStorageClassAsync
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStorageClassAsync($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteStorageClassAsyncWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStorageClassAsyncWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteStorageClassRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStorageClass'
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStorageClassRequest($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteStorageClass'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteStorageClass'
            );
        }

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPIResources
     *
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1APIResourceList
     */
    public function getAPIResources()
    {
        list($response) = $this->getAPIResourcesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAPIResourcesWithHttpInfo
     *
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1APIResourceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPIResourcesWithHttpInfo()
    {
        $returnType = '\CBSi\Kubernetes\Model\V1APIResourceList';
        $request = $this->getAPIResourcesRequest();

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1APIResourceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPIResourcesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPIResourcesAsync()
    {
        return $this->getAPIResourcesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPIResourcesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPIResourcesAsyncWithHttpInfo()
    {
        $returnType = '\CBSi\Kubernetes\Model\V1APIResourceList';
        $request = $this->getAPIResourcesRequest();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPIResources'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAPIResourcesRequest()
    {

        $resourcePath = '/apis/storage.k8s.io/v1/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStorageClass
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1StorageClassList
     */
    public function listStorageClass($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listStorageClassWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listStorageClassWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1StorageClassList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listStorageClassWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClassList';
        $request = $this->listStorageClassRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1StorageClassList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listStorageClassAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStorageClassAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listStorageClassAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStorageClassAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClassList';
        $request = $this->listStorageClassRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStorageClass'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listStorageClassRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchStorageClass
     *
     * @param  string $name name of the StorageClass (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1StorageClass
     */
    public function patchStorageClass($name, $body, $pretty = null)
    {
        list($response) = $this->patchStorageClassWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchStorageClassWithHttpInfo
     *
     * @param  string $name name of the StorageClass (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1StorageClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchStorageClassWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->patchStorageClassRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1StorageClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchStorageClassAsync
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchStorageClassAsync($name, $body, $pretty = null)
    {
        return $this->patchStorageClassAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchStorageClassAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->patchStorageClassRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchStorageClass'
     *
     * @param  string $name name of the StorageClass (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchStorageClassRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchStorageClass'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchStorageClass'
            );
        }

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readStorageClass
     *
     * @param  string $name name of the StorageClass (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1StorageClass
     */
    public function readStorageClass($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readStorageClassWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readStorageClassWithHttpInfo
     *
     * @param  string $name name of the StorageClass (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1StorageClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function readStorageClassWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->readStorageClassRequest($name, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1StorageClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readStorageClassAsync
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readStorageClassAsync($name, $pretty = null, $exact = null, $export = null)
    {
        return $this->readStorageClassAsyncWithHttpInfo($name, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readStorageClassAsyncWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->readStorageClassRequest($name, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readStorageClass'
     *
     * @param  string $name name of the StorageClass (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readStorageClassRequest($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readStorageClass'
            );
        }

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceStorageClass
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1StorageClass
     */
    public function replaceStorageClass($name, $body, $pretty = null)
    {
        list($response) = $this->replaceStorageClassWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceStorageClassWithHttpInfo
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1StorageClass, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceStorageClassWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->replaceStorageClassRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1StorageClass',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceStorageClassAsync
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStorageClassAsync($name, $body, $pretty = null)
    {
        return $this->replaceStorageClassAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceStorageClassAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceStorageClassAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1StorageClass';
        $request = $this->replaceStorageClassRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceStorageClass'
     *
     * @param  string $name name of the StorageClass (required)
     * @param  \CBSi\Kubernetes\Model\V1StorageClass $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceStorageClassRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceStorageClass'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceStorageClass'
            );
        }

        $resourcePath = '/apis/storage.k8s.io/v1/storageclasses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
