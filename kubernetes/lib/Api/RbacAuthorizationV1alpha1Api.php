<?php
/**
 * RbacAuthorizationV1alpha1Api
 * PHP version 5
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CBSi\Kubernetes\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use CBSi\Kubernetes\ApiException;
use CBSi\Kubernetes\Configuration;
use CBSi\Kubernetes\HeaderSelector;
use CBSi\Kubernetes\ObjectSerializer;

/**
 * RbacAuthorizationV1alpha1Api Class Doc Comment
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RbacAuthorizationV1alpha1Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createClusterRole
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRole
     */
    public function createClusterRole($body, $pretty = null)
    {
        list($response) = $this->createClusterRoleWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createClusterRoleWithHttpInfo
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRole, HTTP status code, HTTP response headers (array of strings)
     */
    public function createClusterRoleWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->createClusterRoleRequest($body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRole',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createClusterRoleAsync
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClusterRoleAsync($body, $pretty = null)
    {
        return $this->createClusterRoleAsyncWithHttpInfo($body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClusterRoleAsyncWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->createClusterRoleRequest($body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createClusterRole'
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createClusterRoleRequest($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createClusterRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createClusterRoleBinding
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding
     */
    public function createClusterRoleBinding($body, $pretty = null)
    {
        list($response) = $this->createClusterRoleBindingWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createClusterRoleBindingWithHttpInfo
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function createClusterRoleBindingWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->createClusterRoleBindingRequest($body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createClusterRoleBindingAsync
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClusterRoleBindingAsync($body, $pretty = null)
    {
        return $this->createClusterRoleBindingAsyncWithHttpInfo($body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClusterRoleBindingAsyncWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->createClusterRoleBindingRequest($body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createClusterRoleBinding'
     *
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createClusterRoleBindingRequest($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createClusterRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedRole
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1Role
     */
    public function createNamespacedRole($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedRoleWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedRoleWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedRoleWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->createNamespacedRoleRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedRoleAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedRoleAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedRoleAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedRoleAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->createNamespacedRoleRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedRole'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedRoleRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedRoleBinding
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleBinding
     */
    public function createNamespacedRoleBinding($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedRoleBindingWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedRoleBindingWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->createNamespacedRoleBindingRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedRoleBindingAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedRoleBindingAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedRoleBindingAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->createNamespacedRoleBindingRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedRoleBinding'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedRoleBindingRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteClusterRole
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteClusterRole($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteClusterRoleWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteClusterRoleWithHttpInfo
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteClusterRoleWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteClusterRoleRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteClusterRoleAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteClusterRoleAsync($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteClusterRoleAsyncWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteClusterRoleAsyncWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteClusterRoleRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteClusterRole'
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteClusterRoleRequest($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteClusterRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteClusterRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteClusterRoleBinding
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteClusterRoleBinding($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteClusterRoleBindingWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteClusterRoleBindingWithHttpInfo
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteClusterRoleBindingWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteClusterRoleBindingRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteClusterRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteClusterRoleBindingAsync($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteClusterRoleBindingAsyncWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteClusterRoleBindingAsyncWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteClusterRoleBindingRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteClusterRoleBinding'
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteClusterRoleBindingRequest($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteClusterRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteClusterRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionClusterRole
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionClusterRole($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionClusterRoleWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionClusterRoleWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionClusterRoleWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionClusterRoleRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionClusterRoleAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionClusterRoleAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionClusterRoleAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionClusterRoleAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionClusterRoleRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionClusterRole'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionClusterRoleRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionClusterRoleBinding
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionClusterRoleBinding($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionClusterRoleBindingWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionClusterRoleBindingWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionClusterRoleBindingWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionClusterRoleBindingRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionClusterRoleBindingAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionClusterRoleBindingAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionClusterRoleBindingAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionClusterRoleBindingAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionClusterRoleBindingRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionClusterRoleBinding'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionClusterRoleBindingRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedRole
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedRole($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedRoleWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedRoleWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedRoleWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedRoleRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedRoleAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedRoleAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedRoleAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedRoleAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedRoleRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedRole'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedRoleRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedRoleBinding
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedRoleBinding($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedRoleBindingWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedRoleBindingWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedRoleBindingRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedRoleBindingAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedRoleBindingAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedRoleBindingAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedRoleBindingRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedRoleBinding'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedRoleBindingRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedRole
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedRole($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedRoleWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedRoleWithHttpInfo
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedRoleWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedRoleRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedRoleAsync
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedRoleAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedRoleAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedRoleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedRoleRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedRole'
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedRoleRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedRole'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedRoleBinding
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedRoleBinding($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedRoleBindingWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedRoleBindingWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedRoleBindingRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedRoleBindingAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedRoleBindingRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedRoleBinding'
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedRoleBindingRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPIResources
     *
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1APIResourceList
     */
    public function getAPIResources()
    {
        list($response) = $this->getAPIResourcesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAPIResourcesWithHttpInfo
     *
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1APIResourceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPIResourcesWithHttpInfo()
    {
        $returnType = '\CBSi\Kubernetes\Model\V1APIResourceList';
        $request = $this->getAPIResourcesRequest();

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1APIResourceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPIResourcesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPIResourcesAsync()
    {
        return $this->getAPIResourcesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPIResourcesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPIResourcesAsyncWithHttpInfo()
    {
        $returnType = '\CBSi\Kubernetes\Model\V1APIResourceList';
        $request = $this->getAPIResourcesRequest();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPIResources'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAPIResourcesRequest()
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listClusterRole
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRoleList
     */
    public function listClusterRole($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listClusterRoleWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listClusterRoleWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRoleList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listClusterRoleWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleList';
        $request = $this->listClusterRoleRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listClusterRoleAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listClusterRoleAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listClusterRoleAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listClusterRoleAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleList';
        $request = $this->listClusterRoleRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listClusterRole'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listClusterRoleRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listClusterRoleBinding
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBindingList
     */
    public function listClusterRoleBinding($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listClusterRoleBindingWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listClusterRoleBindingWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBindingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listClusterRoleBindingWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBindingList';
        $request = $this->listClusterRoleBindingRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBindingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listClusterRoleBindingAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listClusterRoleBindingAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listClusterRoleBindingAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listClusterRoleBindingAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBindingList';
        $request = $this->listClusterRoleBindingRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listClusterRoleBinding'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listClusterRoleBindingRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedRole
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleList
     */
    public function listNamespacedRole($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedRoleWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedRoleWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedRoleWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleList';
        $request = $this->listNamespacedRoleRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedRoleAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedRoleAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedRoleAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedRoleAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleList';
        $request = $this->listNamespacedRoleRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedRole'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedRoleRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedRoleBinding
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleBindingList
     */
    public function listNamespacedRoleBinding($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedRoleBindingWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleBindingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedRoleBindingWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBindingList';
        $request = $this->listNamespacedRoleBindingRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleBindingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedRoleBindingAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedRoleBindingAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedRoleBindingAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBindingList';
        $request = $this->listNamespacedRoleBindingRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedRoleBinding'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedRoleBindingRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRoleBindingForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleBindingList
     */
    public function listRoleBindingForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listRoleBindingForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listRoleBindingForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleBindingList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRoleBindingForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBindingList';
        $request = $this->listRoleBindingForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleBindingList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listRoleBindingForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRoleBindingForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listRoleBindingForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRoleBindingForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRoleBindingForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBindingList';
        $request = $this->listRoleBindingForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRoleBindingForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listRoleBindingForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRoleForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleList
     */
    public function listRoleForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listRoleForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listRoleForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRoleForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleList';
        $request = $this->listRoleForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listRoleForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRoleForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listRoleForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRoleForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRoleForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleList';
        $request = $this->listRoleForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRoleForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listRoleForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchClusterRole
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRole
     */
    public function patchClusterRole($name, $body, $pretty = null)
    {
        list($response) = $this->patchClusterRoleWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchClusterRoleWithHttpInfo
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRole, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchClusterRoleWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->patchClusterRoleRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRole',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchClusterRoleAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchClusterRoleAsync($name, $body, $pretty = null)
    {
        return $this->patchClusterRoleAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchClusterRoleAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->patchClusterRoleRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchClusterRole'
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchClusterRoleRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchClusterRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchClusterRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchClusterRoleBinding
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding
     */
    public function patchClusterRoleBinding($name, $body, $pretty = null)
    {
        list($response) = $this->patchClusterRoleBindingWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchClusterRoleBindingWithHttpInfo
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchClusterRoleBindingWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->patchClusterRoleBindingRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchClusterRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchClusterRoleBindingAsync($name, $body, $pretty = null)
    {
        return $this->patchClusterRoleBindingAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchClusterRoleBindingAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->patchClusterRoleBindingRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchClusterRoleBinding'
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchClusterRoleBindingRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchClusterRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchClusterRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedRole
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1Role
     */
    public function patchNamespacedRole($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedRoleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedRoleWithHttpInfo
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedRoleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->patchNamespacedRoleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedRoleAsync
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedRoleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedRoleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedRoleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->patchNamespacedRoleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedRole'
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedRoleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedRole'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedRoleBinding
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleBinding
     */
    public function patchNamespacedRoleBinding($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedRoleBindingWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedRoleBindingWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->patchNamespacedRoleBindingRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedRoleBindingAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->patchNamespacedRoleBindingRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedRoleBinding'
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedRoleBindingRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readClusterRole
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRole
     */
    public function readClusterRole($name, $pretty = null)
    {
        list($response) = $this->readClusterRoleWithHttpInfo($name, $pretty);
        return $response;
    }

    /**
     * Operation readClusterRoleWithHttpInfo
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRole, HTTP status code, HTTP response headers (array of strings)
     */
    public function readClusterRoleWithHttpInfo($name, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->readClusterRoleRequest($name, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRole',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readClusterRoleAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readClusterRoleAsync($name, $pretty = null)
    {
        return $this->readClusterRoleAsyncWithHttpInfo($name, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readClusterRoleAsyncWithHttpInfo($name, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->readClusterRoleRequest($name, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readClusterRole'
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readClusterRoleRequest($name, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readClusterRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readClusterRoleBinding
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding
     */
    public function readClusterRoleBinding($name, $pretty = null)
    {
        list($response) = $this->readClusterRoleBindingWithHttpInfo($name, $pretty);
        return $response;
    }

    /**
     * Operation readClusterRoleBindingWithHttpInfo
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function readClusterRoleBindingWithHttpInfo($name, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->readClusterRoleBindingRequest($name, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readClusterRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readClusterRoleBindingAsync($name, $pretty = null)
    {
        return $this->readClusterRoleBindingAsyncWithHttpInfo($name, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readClusterRoleBindingAsyncWithHttpInfo($name, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->readClusterRoleBindingRequest($name, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readClusterRoleBinding'
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readClusterRoleBindingRequest($name, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readClusterRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedRole
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1Role
     */
    public function readNamespacedRole($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedRoleWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedRoleWithHttpInfo
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedRoleWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->readNamespacedRoleRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedRoleAsync
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedRoleAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedRoleAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedRoleAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->readNamespacedRoleRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedRole'
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedRoleRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedRole'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedRoleBinding
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleBinding
     */
    public function readNamespacedRoleBinding($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedRoleBindingWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedRoleBindingWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->readNamespacedRoleBindingRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedRoleBindingAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->readNamespacedRoleBindingRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedRoleBinding'
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedRoleBindingRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceClusterRole
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRole
     */
    public function replaceClusterRole($name, $body, $pretty = null)
    {
        list($response) = $this->replaceClusterRoleWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceClusterRoleWithHttpInfo
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRole, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceClusterRoleWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->replaceClusterRoleRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRole',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceClusterRoleAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceClusterRoleAsync($name, $body, $pretty = null)
    {
        return $this->replaceClusterRoleAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceClusterRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceClusterRoleAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRole';
        $request = $this->replaceClusterRoleRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceClusterRole'
     *
     * @param  string $name name of the ClusterRole (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRole $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceClusterRoleRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceClusterRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceClusterRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceClusterRoleBinding
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding
     */
    public function replaceClusterRoleBinding($name, $body, $pretty = null)
    {
        list($response) = $this->replaceClusterRoleBindingWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceClusterRoleBindingWithHttpInfo
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceClusterRoleBindingWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->replaceClusterRoleBindingRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceClusterRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceClusterRoleBindingAsync($name, $body, $pretty = null)
    {
        return $this->replaceClusterRoleBindingAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceClusterRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceClusterRoleBindingAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding';
        $request = $this->replaceClusterRoleBindingRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceClusterRoleBinding'
     *
     * @param  string $name name of the ClusterRoleBinding (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1ClusterRoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceClusterRoleBindingRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceClusterRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceClusterRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedRole
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1Role
     */
    public function replaceNamespacedRole($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedRoleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedRoleWithHttpInfo
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1Role, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedRoleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->replaceNamespacedRoleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1Role',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedRoleAsync
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedRoleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedRoleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedRoleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1Role';
        $request = $this->replaceNamespacedRoleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedRole'
     *
     * @param  string $name name of the Role (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1Role $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedRoleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedRole'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedRole'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedRole'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedRoleBinding
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1alpha1RoleBinding
     */
    public function replaceNamespacedRoleBinding($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedRoleBindingWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedRoleBindingWithHttpInfo
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1alpha1RoleBinding, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedRoleBindingWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->replaceNamespacedRoleBindingRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1alpha1RoleBinding',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedRoleBindingAsync
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedRoleBindingAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedRoleBindingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedRoleBindingAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1alpha1RoleBinding';
        $request = $this->replaceNamespacedRoleBindingRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedRoleBinding'
     *
     * @param  string $name name of the RoleBinding (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1alpha1RoleBinding $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedRoleBindingRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedRoleBinding'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedRoleBinding'
            );
        }

        $resourcePath = '/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
