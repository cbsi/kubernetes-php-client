<?php
/**
 * ExtensionsV1beta1Api
 * PHP version 5
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CBSi\Kubernetes\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use CBSi\Kubernetes\ApiException;
use CBSi\Kubernetes\Configuration;
use CBSi\Kubernetes\HeaderSelector;
use CBSi\Kubernetes\ObjectSerializer;

/**
 * ExtensionsV1beta1Api Class Doc Comment
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ExtensionsV1beta1Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNamespacedDaemonSet
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function createNamespacedDaemonSet($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedDaemonSetWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedDaemonSetWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->createNamespacedDaemonSetRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedDaemonSetAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedDaemonSetAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedDaemonSetAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->createNamespacedDaemonSetRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedDaemonSet'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedDaemonSetRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedDeployment
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function createNamespacedDeployment($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedDeploymentWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedDeploymentWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedDeploymentWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->createNamespacedDeploymentRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedDeploymentAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedDeploymentAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedDeploymentAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->createNamespacedDeploymentRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedDeployment'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedDeploymentRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedDeployment'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedDeploymentRollback
     *
     * @param  string $name name of the DeploymentRollback (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback
     */
    public function createNamespacedDeploymentRollback($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedDeploymentRollbackWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedDeploymentRollbackWithHttpInfo
     *
     * @param  string $name name of the DeploymentRollback (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedDeploymentRollbackWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback';
        $request = $this->createNamespacedDeploymentRollbackRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedDeploymentRollbackAsync
     *
     * 
     *
     * @param  string $name name of the DeploymentRollback (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedDeploymentRollbackAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->createNamespacedDeploymentRollbackAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedDeploymentRollbackAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DeploymentRollback (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedDeploymentRollbackAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback';
        $request = $this->createNamespacedDeploymentRollbackRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedDeploymentRollback'
     *
     * @param  string $name name of the DeploymentRollback (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentRollback $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedDeploymentRollbackRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createNamespacedDeploymentRollback'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedDeploymentRollback'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedDeploymentRollback'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedIngress
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function createNamespacedIngress($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedIngressWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedIngressWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedIngressWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->createNamespacedIngressRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedIngressAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedIngressAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedIngressAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedIngressAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->createNamespacedIngressRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedIngress'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedIngressRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedIngress'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedNetworkPolicy
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1NetworkPolicy
     */
    public function createNamespacedNetworkPolicy($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedNetworkPolicyWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1NetworkPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedNetworkPolicyWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->createNamespacedNetworkPolicyRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedNetworkPolicyAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedNetworkPolicyAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedNetworkPolicyAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->createNamespacedNetworkPolicyRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedNetworkPolicy'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedNetworkPolicyRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedReplicaSet
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function createNamespacedReplicaSet($namespace, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedReplicaSetWithHttpInfo($namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedReplicaSetWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->createNamespacedReplicaSetRequest($namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedReplicaSetAsync($namespace, $body, $pretty = null)
    {
        return $this->createNamespacedReplicaSetAsyncWithHttpInfo($namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedReplicaSetAsyncWithHttpInfo($namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->createNamespacedReplicaSetRequest($namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedReplicaSet'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedReplicaSetRequest($namespace, $body, $pretty = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPodSecurityPolicy
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy
     */
    public function createPodSecurityPolicy($body, $pretty = null)
    {
        list($response) = $this->createPodSecurityPolicyWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createPodSecurityPolicyWithHttpInfo
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPodSecurityPolicyWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->createPodSecurityPolicyRequest($body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPodSecurityPolicyAsync
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPodSecurityPolicyAsync($body, $pretty = null)
    {
        return $this->createPodSecurityPolicyAsyncWithHttpInfo($body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPodSecurityPolicyAsyncWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->createPodSecurityPolicyRequest($body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPodSecurityPolicy'
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createPodSecurityPolicyRequest($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createPodSecurityPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createThirdPartyResource
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource
     */
    public function createThirdPartyResource($body, $pretty = null)
    {
        list($response) = $this->createThirdPartyResourceWithHttpInfo($body, $pretty);
        return $response;
    }

    /**
     * Operation createThirdPartyResourceWithHttpInfo
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource, HTTP status code, HTTP response headers (array of strings)
     */
    public function createThirdPartyResourceWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->createThirdPartyResourceRequest($body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createThirdPartyResourceAsync
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createThirdPartyResourceAsync($body, $pretty = null)
    {
        return $this->createThirdPartyResourceAsyncWithHttpInfo($body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createThirdPartyResourceAsyncWithHttpInfo($body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->createThirdPartyResourceRequest($body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createThirdPartyResource'
     *
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createThirdPartyResourceRequest($body, $pretty = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createThirdPartyResource'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedDaemonSet
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedDaemonSet($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedDaemonSetWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedDaemonSetWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedDaemonSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedDaemonSetAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedDaemonSetAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedDaemonSetAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedDaemonSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedDaemonSet'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedDaemonSetRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedDeployment
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedDeployment($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedDeploymentWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedDeploymentWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedDeploymentWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedDeploymentRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedDeploymentAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedDeploymentAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedDeploymentAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedDeploymentRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedDeployment'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedDeploymentRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedIngress
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedIngress($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedIngressWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedIngressWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedIngressWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedIngressRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedIngressAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedIngressAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedIngressAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedIngressAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedIngressRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedIngress'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedIngressRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedNetworkPolicy
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedNetworkPolicy($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedNetworkPolicyWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedNetworkPolicyWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedNetworkPolicyRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedNetworkPolicyAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedNetworkPolicyAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedNetworkPolicyAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedNetworkPolicyRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedNetworkPolicy'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedNetworkPolicyRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionNamespacedReplicaSet
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionNamespacedReplicaSet($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionNamespacedReplicaSetWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionNamespacedReplicaSetWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedReplicaSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedReplicaSetAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionNamespacedReplicaSetAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionNamespacedReplicaSetAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionNamespacedReplicaSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionNamespacedReplicaSet'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionNamespacedReplicaSetRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteCollectionNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionPodSecurityPolicy
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionPodSecurityPolicy($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionPodSecurityPolicyWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionPodSecurityPolicyWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionPodSecurityPolicyWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionPodSecurityPolicyRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionPodSecurityPolicyAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionPodSecurityPolicyAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionPodSecurityPolicyAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionPodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionPodSecurityPolicyAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionPodSecurityPolicyRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionPodSecurityPolicy'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionPodSecurityPolicyRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCollectionThirdPartyResource
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteCollectionThirdPartyResource($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->deleteCollectionThirdPartyResourceWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation deleteCollectionThirdPartyResourceWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCollectionThirdPartyResourceWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionThirdPartyResourceRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCollectionThirdPartyResourceAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionThirdPartyResourceAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->deleteCollectionThirdPartyResourceAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCollectionThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCollectionThirdPartyResourceAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteCollectionThirdPartyResourceRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCollectionThirdPartyResource'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCollectionThirdPartyResourceRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedDaemonSet
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedDaemonSet($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedDaemonSetWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedDaemonSetWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedDaemonSetRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedDaemonSetAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedDaemonSetRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedDaemonSet'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedDaemonSetRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedDeployment
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedDeployment($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedDeploymentWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedDeploymentWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedDeploymentWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedDeploymentRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedDeploymentAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedDeploymentRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedDeployment'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedDeploymentRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedDeployment'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedDeployment'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedIngress
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedIngress($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedIngressWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedIngressWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedIngressWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedIngressRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedIngressAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedIngressAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedIngressAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedIngressAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedIngressRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedIngress'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedIngressRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedIngress'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedIngress'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedNetworkPolicy
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedNetworkPolicy($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedNetworkPolicyAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedNetworkPolicy'
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedReplicaSet
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteNamespacedReplicaSet($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedReplicaSetWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedReplicaSetWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedReplicaSetRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedReplicaSetAsync($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteNamespacedReplicaSetRequest($name, $namespace, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedReplicaSet'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedReplicaSetRequest($name, $namespace, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePodSecurityPolicy
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deletePodSecurityPolicy($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deletePodSecurityPolicyWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deletePodSecurityPolicyWithHttpInfo
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePodSecurityPolicyWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deletePodSecurityPolicyRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePodSecurityPolicyAsync
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePodSecurityPolicyAsync($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deletePodSecurityPolicyAsyncWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePodSecurityPolicyAsyncWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deletePodSecurityPolicyRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePodSecurityPolicy'
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePodSecurityPolicyRequest($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deletePodSecurityPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deletePodSecurityPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteThirdPartyResource
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1Status
     */
    public function deleteThirdPartyResource($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteThirdPartyResourceWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteThirdPartyResourceWithHttpInfo
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1Status, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteThirdPartyResourceWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteThirdPartyResourceRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1Status',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteThirdPartyResourceAsync
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteThirdPartyResourceAsync($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteThirdPartyResourceAsyncWithHttpInfo($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteThirdPartyResourceAsyncWithHttpInfo($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1Status';
        $request = $this->deleteThirdPartyResourceRequest($name, $body, $pretty, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteThirdPartyResource'
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteThirdPartyResourceRequest($name, $body, $pretty = null, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteThirdPartyResource'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteThirdPartyResource'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPIResources
     *
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1APIResourceList
     */
    public function getAPIResources()
    {
        list($response) = $this->getAPIResourcesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAPIResourcesWithHttpInfo
     *
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1APIResourceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPIResourcesWithHttpInfo()
    {
        $returnType = '\CBSi\Kubernetes\Model\V1APIResourceList';
        $request = $this->getAPIResourcesRequest();

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1APIResourceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPIResourcesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPIResourcesAsync()
    {
        return $this->getAPIResourcesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPIResourcesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPIResourcesAsyncWithHttpInfo()
    {
        $returnType = '\CBSi\Kubernetes\Model\V1APIResourceList';
        $request = $this->getAPIResourcesRequest();

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPIResources'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAPIResourcesRequest()
    {

        $resourcePath = '/apis/extensions/v1beta1/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDaemonSetForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSetList
     */
    public function listDaemonSetForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listDaemonSetForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listDaemonSetForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSetList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDaemonSetForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSetList';
        $request = $this->listDaemonSetForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSetList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDaemonSetForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDaemonSetForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listDaemonSetForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDaemonSetForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDaemonSetForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSetList';
        $request = $this->listDaemonSetForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDaemonSetForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listDaemonSetForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/daemonsets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDeploymentForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList
     */
    public function listDeploymentForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listDeploymentForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listDeploymentForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDeploymentForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList';
        $request = $this->listDeploymentForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDeploymentForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDeploymentForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listDeploymentForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDeploymentForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDeploymentForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList';
        $request = $this->listDeploymentForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDeploymentForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listDeploymentForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIngressForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1IngressList
     */
    public function listIngressForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listIngressForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listIngressForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1IngressList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listIngressForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1IngressList';
        $request = $this->listIngressForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1IngressList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listIngressForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIngressForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listIngressForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIngressForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIngressForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1IngressList';
        $request = $this->listIngressForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listIngressForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listIngressForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/ingresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedDaemonSet
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSetList
     */
    public function listNamespacedDaemonSet($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedDaemonSetWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSetList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedDaemonSetWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSetList';
        $request = $this->listNamespacedDaemonSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSetList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedDaemonSetAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedDaemonSetAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedDaemonSetAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSetList';
        $request = $this->listNamespacedDaemonSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedDaemonSet'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedDaemonSetRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedDeployment
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList
     */
    public function listNamespacedDeployment($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedDeploymentWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedDeploymentWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedDeploymentWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList';
        $request = $this->listNamespacedDeploymentRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedDeploymentAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedDeploymentAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedDeploymentAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1DeploymentList';
        $request = $this->listNamespacedDeploymentRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedDeployment'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedDeploymentRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedIngress
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1IngressList
     */
    public function listNamespacedIngress($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedIngressWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedIngressWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1IngressList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedIngressWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1IngressList';
        $request = $this->listNamespacedIngressRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1IngressList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedIngressAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedIngressAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedIngressAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedIngressAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1IngressList';
        $request = $this->listNamespacedIngressRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedIngress'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedIngressRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedNetworkPolicy
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1NetworkPolicyList
     */
    public function listNamespacedNetworkPolicy($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedNetworkPolicyWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1NetworkPolicyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedNetworkPolicyWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicyList';
        $request = $this->listNamespacedNetworkPolicyRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1NetworkPolicyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedNetworkPolicyAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedNetworkPolicyAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedNetworkPolicyAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicyList';
        $request = $this->listNamespacedNetworkPolicyRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedNetworkPolicy'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedNetworkPolicyRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedReplicaSet
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSetList
     */
    public function listNamespacedReplicaSet($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNamespacedReplicaSetWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSetList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedReplicaSetWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSetList';
        $request = $this->listNamespacedReplicaSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSetList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedReplicaSetAsync($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNamespacedReplicaSetAsyncWithHttpInfo($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedReplicaSetAsyncWithHttpInfo($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSetList';
        $request = $this->listNamespacedReplicaSetRequest($namespace, $pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedReplicaSet'
     *
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedReplicaSetRequest($namespace, $pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNetworkPolicyForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1NetworkPolicyList
     */
    public function listNetworkPolicyForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listNetworkPolicyForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listNetworkPolicyForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1NetworkPolicyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNetworkPolicyForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicyList';
        $request = $this->listNetworkPolicyForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1NetworkPolicyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNetworkPolicyForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNetworkPolicyForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listNetworkPolicyForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNetworkPolicyForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNetworkPolicyForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicyList';
        $request = $this->listNetworkPolicyForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNetworkPolicyForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNetworkPolicyForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/networkpolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPodSecurityPolicy
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicyList
     */
    public function listPodSecurityPolicy($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listPodSecurityPolicyWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listPodSecurityPolicyWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPodSecurityPolicyWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicyList';
        $request = $this->listPodSecurityPolicyRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPodSecurityPolicyAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPodSecurityPolicyAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listPodSecurityPolicyAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPodSecurityPolicyAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicyList';
        $request = $this->listPodSecurityPolicyRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPodSecurityPolicy'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listPodSecurityPolicyRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listReplicaSetForAllNamespaces
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSetList
     */
    public function listReplicaSetForAllNamespaces($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listReplicaSetForAllNamespacesWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listReplicaSetForAllNamespacesWithHttpInfo
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSetList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listReplicaSetForAllNamespacesWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSetList';
        $request = $this->listReplicaSetForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSetList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listReplicaSetForAllNamespacesAsync
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listReplicaSetForAllNamespacesAsync($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listReplicaSetForAllNamespacesAsyncWithHttpInfo($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listReplicaSetForAllNamespacesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listReplicaSetForAllNamespacesAsyncWithHttpInfo($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSetList';
        $request = $this->listReplicaSetForAllNamespacesRequest($field_selector, $include_uninitialized, $label_selector, $pretty, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listReplicaSetForAllNamespaces'
     *
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listReplicaSetForAllNamespacesRequest($field_selector = null, $include_uninitialized = null, $label_selector = null, $pretty = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/replicasets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listThirdPartyResource
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ThirdPartyResourceList
     */
    public function listThirdPartyResource($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        list($response) = $this->listThirdPartyResourceWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);
        return $response;
    }

    /**
     * Operation listThirdPartyResourceWithHttpInfo
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ThirdPartyResourceList, HTTP status code, HTTP response headers (array of strings)
     */
    public function listThirdPartyResourceWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResourceList';
        $request = $this->listThirdPartyResourceRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResourceList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listThirdPartyResourceAsync
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listThirdPartyResourceAsync($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        return $this->listThirdPartyResourceAsyncWithHttpInfo($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listThirdPartyResourceAsyncWithHttpInfo($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResourceList';
        $request = $this->listThirdPartyResourceRequest($pretty, $field_selector, $include_uninitialized, $label_selector, $resource_version, $timeout_seconds, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listThirdPartyResource'
     *
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
     * @param  bool $include_uninitialized If true, partially initialized resources are included in the response. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  int $timeout_seconds Timeout for the list/watch call. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listThirdPartyResourceRequest($pretty = null, $field_selector = null, $include_uninitialized = null, $label_selector = null, $resource_version = null, $timeout_seconds = null, $watch = null)
    {

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($field_selector !== null) {
            $queryParams['fieldSelector'] = ObjectSerializer::toQueryValue($field_selector);
        }
        // query params
        if ($include_uninitialized !== null) {
            $queryParams['includeUninitialized'] = ObjectSerializer::toQueryValue($include_uninitialized);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($timeout_seconds !== null) {
            $queryParams['timeoutSeconds'] = ObjectSerializer::toQueryValue($timeout_seconds);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedDaemonSet
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function patchNamespacedDaemonSet($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedDaemonSetWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedDaemonSetWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->patchNamespacedDaemonSetRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDaemonSetAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->patchNamespacedDaemonSetRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedDaemonSet'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedDaemonSetRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedDaemonSetStatus
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function patchNamespacedDaemonSetStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedDaemonSetStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedDaemonSetStatusWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedDaemonSetStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->patchNamespacedDaemonSetStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedDaemonSetStatusAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDaemonSetStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedDaemonSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedDaemonSetStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDaemonSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->patchNamespacedDaemonSetStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedDaemonSetStatus'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedDaemonSetStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedDaemonSetStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedDaemonSetStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedDaemonSetStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedDeployment
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function patchNamespacedDeployment($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedDeploymentWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedDeploymentWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedDeploymentWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->patchNamespacedDeploymentRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDeploymentAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->patchNamespacedDeploymentRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedDeployment'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedDeploymentRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedDeployment'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedDeployment'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedDeploymentScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function patchNamespacedDeploymentScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedDeploymentScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedDeploymentScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedDeploymentScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->patchNamespacedDeploymentScaleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedDeploymentScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDeploymentScaleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedDeploymentScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedDeploymentScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDeploymentScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->patchNamespacedDeploymentScaleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedDeploymentScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedDeploymentScaleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedDeploymentScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedDeploymentScale'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedDeploymentScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedDeploymentStatus
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function patchNamespacedDeploymentStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedDeploymentStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedDeploymentStatusWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedDeploymentStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->patchNamespacedDeploymentStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedDeploymentStatusAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDeploymentStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedDeploymentStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedDeploymentStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedDeploymentStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->patchNamespacedDeploymentStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedDeploymentStatus'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedDeploymentStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedDeploymentStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedDeploymentStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedDeploymentStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedIngress
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function patchNamespacedIngress($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedIngressWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedIngressWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedIngressWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->patchNamespacedIngressRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedIngressAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedIngressAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedIngressAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedIngressAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->patchNamespacedIngressRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedIngress'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedIngressRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedIngress'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedIngress'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedIngressStatus
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function patchNamespacedIngressStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedIngressStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedIngressStatusWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedIngressStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->patchNamespacedIngressStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedIngressStatusAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedIngressStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedIngressStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedIngressStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedIngressStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->patchNamespacedIngressStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedIngressStatus'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedIngressStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedIngressStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedIngressStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedIngressStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedNetworkPolicy
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1NetworkPolicy
     */
    public function patchNamespacedNetworkPolicy($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1NetworkPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->patchNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedNetworkPolicyAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->patchNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedNetworkPolicy'
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedReplicaSet
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function patchNamespacedReplicaSet($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedReplicaSetWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedReplicaSetWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->patchNamespacedReplicaSetRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicaSetAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->patchNamespacedReplicaSetRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedReplicaSet'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedReplicaSetRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedReplicaSetScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function patchNamespacedReplicaSetScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedReplicaSetScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedReplicaSetScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedReplicaSetScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->patchNamespacedReplicaSetScaleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedReplicaSetScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicaSetScaleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedReplicaSetScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedReplicaSetScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicaSetScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->patchNamespacedReplicaSetScaleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedReplicaSetScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedReplicaSetScaleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedReplicaSetScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedReplicaSetScale'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedReplicaSetScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedReplicaSetStatus
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function patchNamespacedReplicaSetStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedReplicaSetStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedReplicaSetStatusWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedReplicaSetStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->patchNamespacedReplicaSetStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedReplicaSetStatusAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicaSetStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedReplicaSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedReplicaSetStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicaSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->patchNamespacedReplicaSetStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedReplicaSetStatus'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedReplicaSetStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedReplicaSetStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedReplicaSetStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedReplicaSetStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchNamespacedReplicationControllerDummyScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function patchNamespacedReplicationControllerDummyScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->patchNamespacedReplicationControllerDummyScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchNamespacedReplicationControllerDummyScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchNamespacedReplicationControllerDummyScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->patchNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchNamespacedReplicationControllerDummyScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicationControllerDummyScaleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->patchNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->patchNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchNamespacedReplicationControllerDummyScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchNamespacedReplicationControllerDummyScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling patchNamespacedReplicationControllerDummyScale'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchNamespacedReplicationControllerDummyScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchPodSecurityPolicy
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy
     */
    public function patchPodSecurityPolicy($name, $body, $pretty = null)
    {
        list($response) = $this->patchPodSecurityPolicyWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchPodSecurityPolicyWithHttpInfo
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchPodSecurityPolicyWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->patchPodSecurityPolicyRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchPodSecurityPolicyAsync
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPodSecurityPolicyAsync($name, $body, $pretty = null)
    {
        return $this->patchPodSecurityPolicyAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchPodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPodSecurityPolicyAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->patchPodSecurityPolicyRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchPodSecurityPolicy'
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchPodSecurityPolicyRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchPodSecurityPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchPodSecurityPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchThirdPartyResource
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  object $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource
     */
    public function patchThirdPartyResource($name, $body, $pretty = null)
    {
        list($response) = $this->patchThirdPartyResourceWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation patchThirdPartyResourceWithHttpInfo
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchThirdPartyResourceWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->patchThirdPartyResourceRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchThirdPartyResourceAsync
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchThirdPartyResourceAsync($name, $body, $pretty = null)
    {
        return $this->patchThirdPartyResourceAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchThirdPartyResourceAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->patchThirdPartyResourceRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchThirdPartyResource'
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  object $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchThirdPartyResourceRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling patchThirdPartyResource'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling patchThirdPartyResource'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedDaemonSet
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function readNamespacedDaemonSet($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readNamespacedDaemonSetWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedDaemonSetWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->readNamespacedDaemonSetRequest($name, $namespace, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDaemonSetAsync($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        return $this->readNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->readNamespacedDaemonSetRequest($name, $namespace, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedDaemonSet'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedDaemonSetRequest($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedDaemonSetStatus
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function readNamespacedDaemonSetStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedDaemonSetStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedDaemonSetStatusWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedDaemonSetStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->readNamespacedDaemonSetStatusRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedDaemonSetStatusAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDaemonSetStatusAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedDaemonSetStatusAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedDaemonSetStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDaemonSetStatusAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->readNamespacedDaemonSetStatusRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedDaemonSetStatus'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedDaemonSetStatusRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedDaemonSetStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedDaemonSetStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedDeployment
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function readNamespacedDeployment($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readNamespacedDeploymentWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readNamespacedDeploymentWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedDeploymentWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->readNamespacedDeploymentRequest($name, $namespace, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDeploymentAsync($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        return $this->readNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->readNamespacedDeploymentRequest($name, $namespace, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedDeployment'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedDeploymentRequest($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedDeployment'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedDeploymentScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function readNamespacedDeploymentScale($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedDeploymentScaleWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedDeploymentScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedDeploymentScaleWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->readNamespacedDeploymentScaleRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedDeploymentScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDeploymentScaleAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedDeploymentScaleAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedDeploymentScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDeploymentScaleAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->readNamespacedDeploymentScaleRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedDeploymentScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedDeploymentScaleRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedDeploymentScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedDeploymentScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedDeploymentStatus
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function readNamespacedDeploymentStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedDeploymentStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedDeploymentStatusWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedDeploymentStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->readNamespacedDeploymentStatusRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedDeploymentStatusAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDeploymentStatusAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedDeploymentStatusAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedDeploymentStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedDeploymentStatusAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->readNamespacedDeploymentStatusRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedDeploymentStatus'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedDeploymentStatusRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedDeploymentStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedDeploymentStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedIngress
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function readNamespacedIngress($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readNamespacedIngressWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readNamespacedIngressWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedIngressWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->readNamespacedIngressRequest($name, $namespace, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedIngressAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedIngressAsync($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        return $this->readNamespacedIngressAsyncWithHttpInfo($name, $namespace, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedIngressAsyncWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->readNamespacedIngressRequest($name, $namespace, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedIngress'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedIngressRequest($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedIngress'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedIngressStatus
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function readNamespacedIngressStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedIngressStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedIngressStatusWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedIngressStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->readNamespacedIngressStatusRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedIngressStatusAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedIngressStatusAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedIngressStatusAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedIngressStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedIngressStatusAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->readNamespacedIngressStatusRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedIngressStatus'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedIngressStatusRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedIngressStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedIngressStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedNetworkPolicy
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1NetworkPolicy
     */
    public function readNamespacedNetworkPolicy($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1NetworkPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->readNamespacedNetworkPolicyRequest($name, $namespace, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedNetworkPolicyAsync($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        return $this->readNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->readNamespacedNetworkPolicyRequest($name, $namespace, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedNetworkPolicy'
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedNetworkPolicyRequest($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedReplicaSet
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function readNamespacedReplicaSet($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readNamespacedReplicaSetWithHttpInfo($name, $namespace, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedReplicaSetWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->readNamespacedReplicaSetRequest($name, $namespace, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicaSetAsync($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        return $this->readNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->readNamespacedReplicaSetRequest($name, $namespace, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedReplicaSet'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedReplicaSetRequest($name, $namespace, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedReplicaSetScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function readNamespacedReplicaSetScale($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedReplicaSetScaleWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedReplicaSetScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedReplicaSetScaleWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->readNamespacedReplicaSetScaleRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedReplicaSetScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicaSetScaleAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedReplicaSetScaleAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedReplicaSetScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicaSetScaleAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->readNamespacedReplicaSetScaleRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedReplicaSetScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedReplicaSetScaleRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedReplicaSetScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedReplicaSetScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedReplicaSetStatus
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function readNamespacedReplicaSetStatus($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedReplicaSetStatusWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedReplicaSetStatusWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedReplicaSetStatusWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->readNamespacedReplicaSetStatusRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedReplicaSetStatusAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicaSetStatusAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedReplicaSetStatusAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedReplicaSetStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicaSetStatusAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->readNamespacedReplicaSetStatusRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedReplicaSetStatus'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedReplicaSetStatusRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedReplicaSetStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedReplicaSetStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readNamespacedReplicationControllerDummyScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function readNamespacedReplicationControllerDummyScale($name, $namespace, $pretty = null)
    {
        list($response) = $this->readNamespacedReplicationControllerDummyScaleWithHttpInfo($name, $namespace, $pretty);
        return $response;
    }

    /**
     * Operation readNamespacedReplicationControllerDummyScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function readNamespacedReplicationControllerDummyScaleWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->readNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readNamespacedReplicationControllerDummyScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicationControllerDummyScaleAsync($name, $namespace, $pretty = null)
    {
        return $this->readNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo($name, $namespace, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo($name, $namespace, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->readNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readNamespacedReplicationControllerDummyScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readNamespacedReplicationControllerDummyScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling readNamespacedReplicationControllerDummyScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readPodSecurityPolicy
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy
     */
    public function readPodSecurityPolicy($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readPodSecurityPolicyWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readPodSecurityPolicyWithHttpInfo
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function readPodSecurityPolicyWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->readPodSecurityPolicyRequest($name, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readPodSecurityPolicyAsync
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readPodSecurityPolicyAsync($name, $pretty = null, $exact = null, $export = null)
    {
        return $this->readPodSecurityPolicyAsyncWithHttpInfo($name, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readPodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readPodSecurityPolicyAsyncWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->readPodSecurityPolicyRequest($name, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readPodSecurityPolicy'
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readPodSecurityPolicyRequest($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readPodSecurityPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readThirdPartyResource
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource
     */
    public function readThirdPartyResource($name, $pretty = null, $exact = null, $export = null)
    {
        list($response) = $this->readThirdPartyResourceWithHttpInfo($name, $pretty, $exact, $export);
        return $response;
    }

    /**
     * Operation readThirdPartyResourceWithHttpInfo
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource, HTTP status code, HTTP response headers (array of strings)
     */
    public function readThirdPartyResourceWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->readThirdPartyResourceRequest($name, $pretty, $exact, $export);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readThirdPartyResourceAsync
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readThirdPartyResourceAsync($name, $pretty = null, $exact = null, $export = null)
    {
        return $this->readThirdPartyResourceAsyncWithHttpInfo($name, $pretty, $exact, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function readThirdPartyResourceAsyncWithHttpInfo($name, $pretty = null, $exact = null, $export = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->readThirdPartyResourceRequest($name, $pretty, $exact, $export);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readThirdPartyResource'
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  bool $exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
     * @param  bool $export Should this value be exported.  Export strips fields that a user can not specify. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function readThirdPartyResourceRequest($name, $pretty = null, $exact = null, $export = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling readThirdPartyResource'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($exact !== null) {
            $queryParams['exact'] = ObjectSerializer::toQueryValue($exact);
        }
        // query params
        if ($export !== null) {
            $queryParams['export'] = ObjectSerializer::toQueryValue($export);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedDaemonSet
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function replaceNamespacedDaemonSet($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedDaemonSetWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedDaemonSetWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedDaemonSetWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->replaceNamespacedDaemonSetRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedDaemonSetAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDaemonSetAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedDaemonSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDaemonSetAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->replaceNamespacedDaemonSetRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedDaemonSet'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedDaemonSetRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedDaemonSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedDaemonSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedDaemonSetStatus
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1DaemonSet
     */
    public function replaceNamespacedDaemonSetStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedDaemonSetStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedDaemonSetStatusWithHttpInfo
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1DaemonSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedDaemonSetStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->replaceNamespacedDaemonSetStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1DaemonSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedDaemonSetStatusAsync
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDaemonSetStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedDaemonSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedDaemonSetStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDaemonSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1DaemonSet';
        $request = $this->replaceNamespacedDaemonSetStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedDaemonSetStatus'
     *
     * @param  string $name name of the DaemonSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1DaemonSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedDaemonSetStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedDaemonSetStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedDaemonSetStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedDaemonSetStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedDeployment
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function replaceNamespacedDeployment($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedDeploymentWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedDeploymentWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedDeploymentWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->replaceNamespacedDeploymentRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedDeploymentAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDeploymentAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDeploymentAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->replaceNamespacedDeploymentRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedDeployment'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedDeploymentRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedDeployment'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedDeployment'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedDeployment'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedDeploymentScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function replaceNamespacedDeploymentScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedDeploymentScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedDeploymentScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedDeploymentScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->replaceNamespacedDeploymentScaleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedDeploymentScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDeploymentScaleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedDeploymentScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedDeploymentScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDeploymentScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->replaceNamespacedDeploymentScaleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedDeploymentScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedDeploymentScaleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedDeploymentScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedDeploymentScale'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedDeploymentScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedDeploymentStatus
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment
     */
    public function replaceNamespacedDeploymentStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedDeploymentStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedDeploymentStatusWithHttpInfo
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedDeploymentStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->replaceNamespacedDeploymentStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedDeploymentStatusAsync
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDeploymentStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedDeploymentStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedDeploymentStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedDeploymentStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment';
        $request = $this->replaceNamespacedDeploymentStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedDeploymentStatus'
     *
     * @param  string $name name of the Deployment (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Deployment $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedDeploymentStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedDeploymentStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedDeploymentStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedDeploymentStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedIngress
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function replaceNamespacedIngress($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedIngressWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedIngressWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedIngressWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->replaceNamespacedIngressRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedIngressAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedIngressAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedIngressAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedIngressAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedIngressAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->replaceNamespacedIngressRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedIngress'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedIngressRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedIngress'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedIngress'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedIngress'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedIngressStatus
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1Ingress
     */
    public function replaceNamespacedIngressStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedIngressStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedIngressStatusWithHttpInfo
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1Ingress, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedIngressStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->replaceNamespacedIngressStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1Ingress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedIngressStatusAsync
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedIngressStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedIngressStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedIngressStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedIngressStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1Ingress';
        $request = $this->replaceNamespacedIngressStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedIngressStatus'
     *
     * @param  string $name name of the Ingress (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1Ingress $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedIngressStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedIngressStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedIngressStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedIngressStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedNetworkPolicy
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1NetworkPolicy
     */
    public function replaceNamespacedNetworkPolicy($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedNetworkPolicyWithHttpInfo
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1NetworkPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedNetworkPolicyWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->replaceNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedNetworkPolicyAsync
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedNetworkPolicyAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedNetworkPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedNetworkPolicyAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1NetworkPolicy';
        $request = $this->replaceNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedNetworkPolicy'
     *
     * @param  string $name name of the NetworkPolicy (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1NetworkPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedNetworkPolicyRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedNetworkPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedNetworkPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedReplicaSet
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function replaceNamespacedReplicaSet($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedReplicaSetWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedReplicaSetWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedReplicaSetWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->replaceNamespacedReplicaSetRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedReplicaSetAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicaSetAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedReplicaSetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicaSetAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->replaceNamespacedReplicaSetRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedReplicaSet'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedReplicaSetRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedReplicaSet'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedReplicaSet'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedReplicaSetScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function replaceNamespacedReplicaSetScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedReplicaSetScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedReplicaSetScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedReplicaSetScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->replaceNamespacedReplicaSetScaleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedReplicaSetScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicaSetScaleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedReplicaSetScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedReplicaSetScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicaSetScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->replaceNamespacedReplicaSetScaleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedReplicaSetScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedReplicaSetScaleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedReplicaSetScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedReplicaSetScale'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedReplicaSetScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedReplicaSetStatus
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ReplicaSet
     */
    public function replaceNamespacedReplicaSetStatus($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedReplicaSetStatusWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedReplicaSetStatusWithHttpInfo
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ReplicaSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedReplicaSetStatusWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->replaceNamespacedReplicaSetStatusRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ReplicaSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedReplicaSetStatusAsync
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicaSetStatusAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedReplicaSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedReplicaSetStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicaSetStatusAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ReplicaSet';
        $request = $this->replaceNamespacedReplicaSetStatusRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedReplicaSetStatus'
     *
     * @param  string $name name of the ReplicaSet (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ReplicaSet $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedReplicaSetStatusRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedReplicaSetStatus'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedReplicaSetStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedReplicaSetStatus'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedReplicationControllerDummyScale
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale
     */
    public function replaceNamespacedReplicationControllerDummyScale($name, $namespace, $body, $pretty = null)
    {
        list($response) = $this->replaceNamespacedReplicationControllerDummyScaleWithHttpInfo($name, $namespace, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceNamespacedReplicationControllerDummyScaleWithHttpInfo
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedReplicationControllerDummyScaleWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->replaceNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedReplicationControllerDummyScaleAsync
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicationControllerDummyScaleAsync($name, $namespace, $body, $pretty = null)
    {
        return $this->replaceNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedReplicationControllerDummyScaleAsyncWithHttpInfo($name, $namespace, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\ExtensionsV1beta1Scale';
        $request = $this->replaceNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedReplicationControllerDummyScale'
     *
     * @param  string $name name of the Scale (required)
     * @param  string $namespace object name and auth scope, such as for teams and projects (required)
     * @param  \CBSi\Kubernetes\Model\ExtensionsV1beta1Scale $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedReplicationControllerDummyScaleRequest($name, $namespace, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedReplicationControllerDummyScale'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedReplicationControllerDummyScale'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedReplicationControllerDummyScale'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replacePodSecurityPolicy
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy
     */
    public function replacePodSecurityPolicy($name, $body, $pretty = null)
    {
        list($response) = $this->replacePodSecurityPolicyWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replacePodSecurityPolicyWithHttpInfo
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy, HTTP status code, HTTP response headers (array of strings)
     */
    public function replacePodSecurityPolicyWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->replacePodSecurityPolicyRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replacePodSecurityPolicyAsync
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replacePodSecurityPolicyAsync($name, $body, $pretty = null)
    {
        return $this->replacePodSecurityPolicyAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replacePodSecurityPolicyAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replacePodSecurityPolicyAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy';
        $request = $this->replacePodSecurityPolicyRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replacePodSecurityPolicy'
     *
     * @param  string $name name of the PodSecurityPolicy (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1PodSecurityPolicy $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replacePodSecurityPolicyRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replacePodSecurityPolicy'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replacePodSecurityPolicy'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/podsecuritypolicies/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceThirdPartyResource
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource
     */
    public function replaceThirdPartyResource($name, $body, $pretty = null)
    {
        list($response) = $this->replaceThirdPartyResourceWithHttpInfo($name, $body, $pretty);
        return $response;
    }

    /**
     * Operation replaceThirdPartyResourceWithHttpInfo
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceThirdPartyResourceWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->replaceThirdPartyResourceRequest($name, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceThirdPartyResourceAsync
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceThirdPartyResourceAsync($name, $body, $pretty = null)
    {
        return $this->replaceThirdPartyResourceAsyncWithHttpInfo($name, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceThirdPartyResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceThirdPartyResourceAsyncWithHttpInfo($name, $body, $pretty = null)
    {
        $returnType = '\CBSi\Kubernetes\Model\V1beta1ThirdPartyResource';
        $request = $this->replaceThirdPartyResourceRequest($name, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceThirdPartyResource'
     *
     * @param  string $name name of the ThirdPartyResource (required)
     * @param  \CBSi\Kubernetes\Model\V1beta1ThirdPartyResource $body (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceThirdPartyResourceRequest($name, $body, $pretty = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceThirdPartyResource'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceThirdPartyResource'
            );
        }

        $resourcePath = '/apis/extensions/v1beta1/thirdpartyresources/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
