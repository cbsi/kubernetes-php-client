<?php
/**
 * CustomObjectsApi
 * PHP version 5
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CBSi\Kubernetes\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use CBSi\Kubernetes\ApiException;
use CBSi\Kubernetes\Configuration;
use CBSi\Kubernetes\HeaderSelector;
use CBSi\Kubernetes\ObjectSerializer;

/**
 * CustomObjectsApi Class Doc Comment
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CustomObjectsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createClusterCustomObject
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createClusterCustomObject($group, $version, $plural, $body, $pretty = null)
    {
        list($response) = $this->createClusterCustomObjectWithHttpInfo($group, $version, $plural, $body, $pretty);
        return $response;
    }

    /**
     * Operation createClusterCustomObjectWithHttpInfo
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createClusterCustomObjectWithHttpInfo($group, $version, $plural, $body, $pretty = null)
    {
        $returnType = 'object';
        $request = $this->createClusterCustomObjectRequest($group, $version, $plural, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createClusterCustomObjectAsync
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClusterCustomObjectAsync($group, $version, $plural, $body, $pretty = null)
    {
        return $this->createClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createClusterCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $body, $pretty = null)
    {
        $returnType = 'object';
        $request = $this->createClusterCustomObjectRequest($group, $version, $plural, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createClusterCustomObject'
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createClusterCustomObjectRequest($group, $version, $plural, $body, $pretty = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling createClusterCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createClusterCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling createClusterCustomObject'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createClusterCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/{plural}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNamespacedCustomObject
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createNamespacedCustomObject($group, $version, $namespace, $plural, $body, $pretty = null)
    {
        list($response) = $this->createNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $body, $pretty);
        return $response;
    }

    /**
     * Operation createNamespacedCustomObjectWithHttpInfo
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $body, $pretty = null)
    {
        $returnType = 'object';
        $request = $this->createNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $body, $pretty);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNamespacedCustomObjectAsync
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedCustomObjectAsync($group, $version, $namespace, $plural, $body, $pretty = null)
    {
        return $this->createNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $body, $pretty)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNamespacedCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $body, $pretty = null)
    {
        $returnType = 'object';
        $request = $this->createNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $body, $pretty);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNamespacedCustomObject'
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  object $body The JSON schema of the Resource to create. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $body, $pretty = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling createNamespacedCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling createNamespacedCustomObject'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling createNamespacedCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling createNamespacedCustomObject'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createNamespacedCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/namespaces/{namespace}/{plural}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteClusterCustomObject
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteClusterCustomObject($group, $version, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteClusterCustomObjectWithHttpInfo($group, $version, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteClusterCustomObjectWithHttpInfo
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteClusterCustomObjectWithHttpInfo($group, $version, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = 'object';
        $request = $this->deleteClusterCustomObjectRequest($group, $version, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteClusterCustomObjectAsync
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteClusterCustomObjectAsync($group, $version, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteClusterCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = 'object';
        $request = $this->deleteClusterCustomObjectRequest($group, $version, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteClusterCustomObject'
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteClusterCustomObjectRequest($group, $version, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling deleteClusterCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteClusterCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling deleteClusterCustomObject'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteClusterCustomObject'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteClusterCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/{plural}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNamespacedCustomObject
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteNamespacedCustomObject($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        list($response) = $this->deleteNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy);
        return $response;
    }

    /**
     * Operation deleteNamespacedCustomObjectWithHttpInfo
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = 'object';
        $request = $this->deleteNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNamespacedCustomObjectAsync
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedCustomObjectAsync($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        return $this->deleteNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNamespacedCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        $returnType = 'object';
        $request = $this->deleteNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds, $orphan_dependents, $propagation_policy);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNamespacedCustomObject'
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  \CBSi\Kubernetes\Model\V1DeleteOptions $body (required)
     * @param  int $grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
     * @param  bool $orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
     * @param  string $propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name, $body, $grace_period_seconds = null, $orphan_dependents = null, $propagation_policy = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling deleteNamespacedCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling deleteNamespacedCustomObject'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling deleteNamespacedCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling deleteNamespacedCustomObject'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteNamespacedCustomObject'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteNamespacedCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($grace_period_seconds !== null) {
            $queryParams['gracePeriodSeconds'] = ObjectSerializer::toQueryValue($grace_period_seconds);
        }
        // query params
        if ($orphan_dependents !== null) {
            $queryParams['orphanDependents'] = ObjectSerializer::toQueryValue($orphan_dependents);
        }
        // query params
        if ($propagation_policy !== null) {
            $queryParams['propagationPolicy'] = ObjectSerializer::toQueryValue($propagation_policy);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClusterCustomObject
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getClusterCustomObject($group, $version, $plural, $name)
    {
        list($response) = $this->getClusterCustomObjectWithHttpInfo($group, $version, $plural, $name);
        return $response;
    }

    /**
     * Operation getClusterCustomObjectWithHttpInfo
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getClusterCustomObjectWithHttpInfo($group, $version, $plural, $name)
    {
        $returnType = 'object';
        $request = $this->getClusterCustomObjectRequest($group, $version, $plural, $name);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClusterCustomObjectAsync
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClusterCustomObjectAsync($group, $version, $plural, $name)
    {
        return $this->getClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClusterCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $name)
    {
        $returnType = 'object';
        $request = $this->getClusterCustomObjectRequest($group, $version, $plural, $name);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClusterCustomObject'
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClusterCustomObjectRequest($group, $version, $plural, $name)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getClusterCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getClusterCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling getClusterCustomObject'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getClusterCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/{plural}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNamespacedCustomObject
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNamespacedCustomObject($group, $version, $namespace, $plural, $name)
    {
        list($response) = $this->getNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $name);
        return $response;
    }

    /**
     * Operation getNamespacedCustomObjectWithHttpInfo
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $name)
    {
        $returnType = 'object';
        $request = $this->getNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNamespacedCustomObjectAsync
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNamespacedCustomObjectAsync($group, $version, $namespace, $plural, $name)
    {
        return $this->getNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNamespacedCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $name)
    {
        $returnType = 'object';
        $request = $this->getNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNamespacedCustomObject'
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling getNamespacedCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling getNamespacedCustomObject'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling getNamespacedCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling getNamespacedCustomObject'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getNamespacedCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listClusterCustomObject
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function listClusterCustomObject($group, $version, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        list($response) = $this->listClusterCustomObjectWithHttpInfo($group, $version, $plural, $pretty, $label_selector, $resource_version, $watch);
        return $response;
    }

    /**
     * Operation listClusterCustomObjectWithHttpInfo
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listClusterCustomObjectWithHttpInfo($group, $version, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        $returnType = 'object';
        $request = $this->listClusterCustomObjectRequest($group, $version, $plural, $pretty, $label_selector, $resource_version, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listClusterCustomObjectAsync
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listClusterCustomObjectAsync($group, $version, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        return $this->listClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $pretty, $label_selector, $resource_version, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listClusterCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        $returnType = 'object';
        $request = $this->listClusterCustomObjectRequest($group, $version, $plural, $pretty, $label_selector, $resource_version, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listClusterCustomObject'
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listClusterCustomObjectRequest($group, $version, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling listClusterCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listClusterCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling listClusterCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/{plural}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/json;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/json;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNamespacedCustomObject
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function listNamespacedCustomObject($group, $version, $namespace, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        list($response) = $this->listNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $pretty, $label_selector, $resource_version, $watch);
        return $response;
    }

    /**
     * Operation listNamespacedCustomObjectWithHttpInfo
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        $returnType = 'object';
        $request = $this->listNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $pretty, $label_selector, $resource_version, $watch);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNamespacedCustomObjectAsync
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedCustomObjectAsync($group, $version, $namespace, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        return $this->listNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $pretty, $label_selector, $resource_version, $watch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNamespacedCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        $returnType = 'object';
        $request = $this->listNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $pretty, $label_selector, $resource_version, $watch);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNamespacedCustomObject'
     *
     * @param  string $group The custom resource&#39;s group name (required)
     * @param  string $version The custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural The custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $pretty If &#39;true&#39;, then the output is pretty printed. (optional)
     * @param  string $label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
     * @param  string $resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
     * @param  bool $watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $pretty = null, $label_selector = null, $resource_version = null, $watch = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling listNamespacedCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling listNamespacedCustomObject'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling listNamespacedCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling listNamespacedCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/namespaces/{namespace}/{plural}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($label_selector !== null) {
            $queryParams['labelSelector'] = ObjectSerializer::toQueryValue($label_selector);
        }
        // query params
        if ($resource_version !== null) {
            $queryParams['resourceVersion'] = ObjectSerializer::toQueryValue($resource_version);
        }
        // query params
        if ($watch !== null) {
            $queryParams['watch'] = ObjectSerializer::toQueryValue($watch);
        }

        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/json;stream=watch']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/json;stream=watch'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceClusterCustomObject
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function replaceClusterCustomObject($group, $version, $plural, $name, $body)
    {
        list($response) = $this->replaceClusterCustomObjectWithHttpInfo($group, $version, $plural, $name, $body);
        return $response;
    }

    /**
     * Operation replaceClusterCustomObjectWithHttpInfo
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceClusterCustomObjectWithHttpInfo($group, $version, $plural, $name, $body)
    {
        $returnType = 'object';
        $request = $this->replaceClusterCustomObjectRequest($group, $version, $plural, $name, $body);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceClusterCustomObjectAsync
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceClusterCustomObjectAsync($group, $version, $plural, $name, $body)
    {
        return $this->replaceClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceClusterCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceClusterCustomObjectAsyncWithHttpInfo($group, $version, $plural, $name, $body)
    {
        $returnType = 'object';
        $request = $this->replaceClusterCustomObjectRequest($group, $version, $plural, $name, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceClusterCustomObject'
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $plural the custom object&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceClusterCustomObjectRequest($group, $version, $plural, $name, $body)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling replaceClusterCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling replaceClusterCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling replaceClusterCustomObject'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceClusterCustomObject'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceClusterCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/{plural}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceNamespacedCustomObject
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function replaceNamespacedCustomObject($group, $version, $namespace, $plural, $name, $body)
    {
        list($response) = $this->replaceNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $name, $body);
        return $response;
    }

    /**
     * Operation replaceNamespacedCustomObjectWithHttpInfo
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \CBSi\Kubernetes\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceNamespacedCustomObjectWithHttpInfo($group, $version, $namespace, $plural, $name, $body)
    {
        $returnType = 'object';
        $request = $this->replaceNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name, $body);

        try {

            try {
                $response = $this->client->send($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceNamespacedCustomObjectAsync
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedCustomObjectAsync($group, $version, $namespace, $plural, $name, $body)
    {
        return $this->replaceNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceNamespacedCustomObjectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceNamespacedCustomObjectAsyncWithHttpInfo($group, $version, $namespace, $plural, $name, $body)
    {
        $returnType = 'object';
        $request = $this->replaceNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name, $body);

        return $this->client
            ->sendAsync($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceNamespacedCustomObject'
     *
     * @param  string $group the custom resource&#39;s group (required)
     * @param  string $version the custom resource&#39;s version (required)
     * @param  string $namespace The custom resource&#39;s namespace (required)
     * @param  string $plural the custom resource&#39;s plural name. For TPRs this would be lowercase plural kind. (required)
     * @param  string $name the custom object&#39;s name (required)
     * @param  object $body The JSON schema of the Resource to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceNamespacedCustomObjectRequest($group, $version, $namespace, $plural, $name, $body)
    {
        // verify the required parameter 'group' is set
        if ($group === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling replaceNamespacedCustomObject'
            );
        }
        // verify the required parameter 'version' is set
        if ($version === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $version when calling replaceNamespacedCustomObject'
            );
        }
        // verify the required parameter 'namespace' is set
        if ($namespace === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $namespace when calling replaceNamespacedCustomObject'
            );
        }
        // verify the required parameter 'plural' is set
        if ($plural === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plural when calling replaceNamespacedCustomObject'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling replaceNamespacedCustomObject'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceNamespacedCustomObject'
            );
        }

        $resourcePath = '/apis/{group}/{version}/namespaces/{namespace}/{plural}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($group !== null) {
            $resourcePath = str_replace(
                '{' . 'group' . '}',
                ObjectSerializer::toPathValue($group),
                $resourcePath
            );
        }
        // path params
        if ($version !== null) {
            $resourcePath = str_replace(
                '{' . 'version' . '}',
                ObjectSerializer::toPathValue($version),
                $resourcePath
            );
        }
        // path params
        if ($namespace !== null) {
            $resourcePath = str_replace(
                '{' . 'namespace' . '}',
                ObjectSerializer::toPathValue($namespace),
                $resourcePath
            );
        }
        // path params
        if ($plural !== null) {
            $resourcePath = str_replace(
                '{' . 'plural' . '}',
                ObjectSerializer::toPathValue($plural),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present

        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('authorization');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

}
