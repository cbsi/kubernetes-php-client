<?php
/**
 * V1beta1PolicyRule
 *
 * PHP version 5
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CBSi\Kubernetes\Model;

use \ArrayAccess;
use \CBSi\Kubernetes\ObjectSerializer;

/**
 * V1beta1PolicyRule Class Doc Comment
 *
 * @category Class
 * @description PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class V1beta1PolicyRule implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'v1beta1.PolicyRule';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'api_groups' => 'string[]',
        'non_resource_ur_ls' => 'string[]',
        'resource_names' => 'string[]',
        'resources' => 'string[]',
        'verbs' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'api_groups' => null,
        'non_resource_ur_ls' => null,
        'resource_names' => null,
        'resources' => null,
        'verbs' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'api_groups' => 'apiGroups',
        'non_resource_ur_ls' => 'nonResourceURLs',
        'resource_names' => 'resourceNames',
        'resources' => 'resources',
        'verbs' => 'verbs'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'api_groups' => 'setApiGroups',
        'non_resource_ur_ls' => 'setNonResourceUrLs',
        'resource_names' => 'setResourceNames',
        'resources' => 'setResources',
        'verbs' => 'setVerbs'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'api_groups' => 'getApiGroups',
        'non_resource_ur_ls' => 'getNonResourceUrLs',
        'resource_names' => 'getResourceNames',
        'resources' => 'getResources',
        'verbs' => 'getVerbs'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['api_groups'] = isset($data['api_groups']) ? $data['api_groups'] : null;
        $this->container['non_resource_ur_ls'] = isset($data['non_resource_ur_ls']) ? $data['non_resource_ur_ls'] : null;
        $this->container['resource_names'] = isset($data['resource_names']) ? $data['resource_names'] : null;
        $this->container['resources'] = isset($data['resources']) ? $data['resources'] : null;
        $this->container['verbs'] = isset($data['verbs']) ? $data['verbs'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['verbs'] === null) {
            $invalidProperties[] = "'verbs' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        if ($this->container['verbs'] === null) {
            return false;
        }
        return true;
    }


    /**
     * Gets api_groups
     *
     * @return string[]
     */
    public function getApiGroups()
    {
        return $this->container['api_groups'];
    }

    /**
     * Sets api_groups
     *
     * @param string[] $api_groups APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.
     *
     * @return $this
     */
    public function setApiGroups($api_groups)
    {
        $this->container['api_groups'] = $api_groups;

        return $this;
    }

    /**
     * Gets non_resource_ur_ls
     *
     * @return string[]
     */
    public function getNonResourceUrLs()
    {
        return $this->container['non_resource_ur_ls'];
    }

    /**
     * Sets non_resource_ur_ls
     *
     * @param string[] $non_resource_ur_ls NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources (such as \"pods\" or \"secrets\") or non-resource URL paths (such as \"/api\"),  but not both.
     *
     * @return $this
     */
    public function setNonResourceUrLs($non_resource_ur_ls)
    {
        $this->container['non_resource_ur_ls'] = $non_resource_ur_ls;

        return $this;
    }

    /**
     * Gets resource_names
     *
     * @return string[]
     */
    public function getResourceNames()
    {
        return $this->container['resource_names'];
    }

    /**
     * Sets resource_names
     *
     * @param string[] $resource_names ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
     *
     * @return $this
     */
    public function setResourceNames($resource_names)
    {
        $this->container['resource_names'] = $resource_names;

        return $this;
    }

    /**
     * Gets resources
     *
     * @return string[]
     */
    public function getResources()
    {
        return $this->container['resources'];
    }

    /**
     * Sets resources
     *
     * @param string[] $resources Resources is a list of resources this rule applies to.  ResourceAll represents all resources.
     *
     * @return $this
     */
    public function setResources($resources)
    {
        $this->container['resources'] = $resources;

        return $this;
    }

    /**
     * Gets verbs
     *
     * @return string[]
     */
    public function getVerbs()
    {
        return $this->container['verbs'];
    }

    /**
     * Sets verbs
     *
     * @param string[] $verbs Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule.  VerbAll represents all kinds.
     *
     * @return $this
     */
    public function setVerbs($verbs)
    {
        $this->container['verbs'] = $verbs;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


