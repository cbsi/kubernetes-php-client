<?php
/**
 * V1PersistentVolumeSpec
 *
 * PHP version 5
 *
 * @category Class
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Kubernetes
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CBSi\Kubernetes\Model;

use \ArrayAccess;
use \CBSi\Kubernetes\ObjectSerializer;

/**
 * V1PersistentVolumeSpec Class Doc Comment
 *
 * @category Class
 * @description PersistentVolumeSpec is the specification of a persistent volume.
 * @package  CBSi\Kubernetes
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class V1PersistentVolumeSpec implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'v1.PersistentVolumeSpec';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'access_modes' => 'string[]',
        'aws_elastic_block_store' => '\CBSi\Kubernetes\Model\V1AWSElasticBlockStoreVolumeSource',
        'azure_disk' => '\CBSi\Kubernetes\Model\V1AzureDiskVolumeSource',
        'azure_file' => '\CBSi\Kubernetes\Model\V1AzureFileVolumeSource',
        'capacity' => 'map[string,string]',
        'cephfs' => '\CBSi\Kubernetes\Model\V1CephFSVolumeSource',
        'cinder' => '\CBSi\Kubernetes\Model\V1CinderVolumeSource',
        'claim_ref' => '\CBSi\Kubernetes\Model\V1ObjectReference',
        'fc' => '\CBSi\Kubernetes\Model\V1FCVolumeSource',
        'flex_volume' => '\CBSi\Kubernetes\Model\V1FlexVolumeSource',
        'flocker' => '\CBSi\Kubernetes\Model\V1FlockerVolumeSource',
        'gce_persistent_disk' => '\CBSi\Kubernetes\Model\V1GCEPersistentDiskVolumeSource',
        'glusterfs' => '\CBSi\Kubernetes\Model\V1GlusterfsVolumeSource',
        'host_path' => '\CBSi\Kubernetes\Model\V1HostPathVolumeSource',
        'iscsi' => '\CBSi\Kubernetes\Model\V1ISCSIVolumeSource',
        'local' => '\CBSi\Kubernetes\Model\V1LocalVolumeSource',
        'nfs' => '\CBSi\Kubernetes\Model\V1NFSVolumeSource',
        'persistent_volume_reclaim_policy' => 'string',
        'photon_persistent_disk' => '\CBSi\Kubernetes\Model\V1PhotonPersistentDiskVolumeSource',
        'portworx_volume' => '\CBSi\Kubernetes\Model\V1PortworxVolumeSource',
        'quobyte' => '\CBSi\Kubernetes\Model\V1QuobyteVolumeSource',
        'rbd' => '\CBSi\Kubernetes\Model\V1RBDVolumeSource',
        'scale_io' => '\CBSi\Kubernetes\Model\V1ScaleIOVolumeSource',
        'storage_class_name' => 'string',
        'storageos' => '\CBSi\Kubernetes\Model\V1StorageOSPersistentVolumeSource',
        'vsphere_volume' => '\CBSi\Kubernetes\Model\V1VsphereVirtualDiskVolumeSource'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'access_modes' => null,
        'aws_elastic_block_store' => null,
        'azure_disk' => null,
        'azure_file' => null,
        'capacity' => null,
        'cephfs' => null,
        'cinder' => null,
        'claim_ref' => null,
        'fc' => null,
        'flex_volume' => null,
        'flocker' => null,
        'gce_persistent_disk' => null,
        'glusterfs' => null,
        'host_path' => null,
        'iscsi' => null,
        'local' => null,
        'nfs' => null,
        'persistent_volume_reclaim_policy' => null,
        'photon_persistent_disk' => null,
        'portworx_volume' => null,
        'quobyte' => null,
        'rbd' => null,
        'scale_io' => null,
        'storage_class_name' => null,
        'storageos' => null,
        'vsphere_volume' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'access_modes' => 'accessModes',
        'aws_elastic_block_store' => 'awsElasticBlockStore',
        'azure_disk' => 'azureDisk',
        'azure_file' => 'azureFile',
        'capacity' => 'capacity',
        'cephfs' => 'cephfs',
        'cinder' => 'cinder',
        'claim_ref' => 'claimRef',
        'fc' => 'fc',
        'flex_volume' => 'flexVolume',
        'flocker' => 'flocker',
        'gce_persistent_disk' => 'gcePersistentDisk',
        'glusterfs' => 'glusterfs',
        'host_path' => 'hostPath',
        'iscsi' => 'iscsi',
        'local' => 'local',
        'nfs' => 'nfs',
        'persistent_volume_reclaim_policy' => 'persistentVolumeReclaimPolicy',
        'photon_persistent_disk' => 'photonPersistentDisk',
        'portworx_volume' => 'portworxVolume',
        'quobyte' => 'quobyte',
        'rbd' => 'rbd',
        'scale_io' => 'scaleIO',
        'storage_class_name' => 'storageClassName',
        'storageos' => 'storageos',
        'vsphere_volume' => 'vsphereVolume'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'access_modes' => 'setAccessModes',
        'aws_elastic_block_store' => 'setAwsElasticBlockStore',
        'azure_disk' => 'setAzureDisk',
        'azure_file' => 'setAzureFile',
        'capacity' => 'setCapacity',
        'cephfs' => 'setCephfs',
        'cinder' => 'setCinder',
        'claim_ref' => 'setClaimRef',
        'fc' => 'setFc',
        'flex_volume' => 'setFlexVolume',
        'flocker' => 'setFlocker',
        'gce_persistent_disk' => 'setGcePersistentDisk',
        'glusterfs' => 'setGlusterfs',
        'host_path' => 'setHostPath',
        'iscsi' => 'setIscsi',
        'local' => 'setLocal',
        'nfs' => 'setNfs',
        'persistent_volume_reclaim_policy' => 'setPersistentVolumeReclaimPolicy',
        'photon_persistent_disk' => 'setPhotonPersistentDisk',
        'portworx_volume' => 'setPortworxVolume',
        'quobyte' => 'setQuobyte',
        'rbd' => 'setRbd',
        'scale_io' => 'setScaleIo',
        'storage_class_name' => 'setStorageClassName',
        'storageos' => 'setStorageos',
        'vsphere_volume' => 'setVsphereVolume'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'access_modes' => 'getAccessModes',
        'aws_elastic_block_store' => 'getAwsElasticBlockStore',
        'azure_disk' => 'getAzureDisk',
        'azure_file' => 'getAzureFile',
        'capacity' => 'getCapacity',
        'cephfs' => 'getCephfs',
        'cinder' => 'getCinder',
        'claim_ref' => 'getClaimRef',
        'fc' => 'getFc',
        'flex_volume' => 'getFlexVolume',
        'flocker' => 'getFlocker',
        'gce_persistent_disk' => 'getGcePersistentDisk',
        'glusterfs' => 'getGlusterfs',
        'host_path' => 'getHostPath',
        'iscsi' => 'getIscsi',
        'local' => 'getLocal',
        'nfs' => 'getNfs',
        'persistent_volume_reclaim_policy' => 'getPersistentVolumeReclaimPolicy',
        'photon_persistent_disk' => 'getPhotonPersistentDisk',
        'portworx_volume' => 'getPortworxVolume',
        'quobyte' => 'getQuobyte',
        'rbd' => 'getRbd',
        'scale_io' => 'getScaleIo',
        'storage_class_name' => 'getStorageClassName',
        'storageos' => 'getStorageos',
        'vsphere_volume' => 'getVsphereVolume'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['access_modes'] = isset($data['access_modes']) ? $data['access_modes'] : null;
        $this->container['aws_elastic_block_store'] = isset($data['aws_elastic_block_store']) ? $data['aws_elastic_block_store'] : null;
        $this->container['azure_disk'] = isset($data['azure_disk']) ? $data['azure_disk'] : null;
        $this->container['azure_file'] = isset($data['azure_file']) ? $data['azure_file'] : null;
        $this->container['capacity'] = isset($data['capacity']) ? $data['capacity'] : null;
        $this->container['cephfs'] = isset($data['cephfs']) ? $data['cephfs'] : null;
        $this->container['cinder'] = isset($data['cinder']) ? $data['cinder'] : null;
        $this->container['claim_ref'] = isset($data['claim_ref']) ? $data['claim_ref'] : null;
        $this->container['fc'] = isset($data['fc']) ? $data['fc'] : null;
        $this->container['flex_volume'] = isset($data['flex_volume']) ? $data['flex_volume'] : null;
        $this->container['flocker'] = isset($data['flocker']) ? $data['flocker'] : null;
        $this->container['gce_persistent_disk'] = isset($data['gce_persistent_disk']) ? $data['gce_persistent_disk'] : null;
        $this->container['glusterfs'] = isset($data['glusterfs']) ? $data['glusterfs'] : null;
        $this->container['host_path'] = isset($data['host_path']) ? $data['host_path'] : null;
        $this->container['iscsi'] = isset($data['iscsi']) ? $data['iscsi'] : null;
        $this->container['local'] = isset($data['local']) ? $data['local'] : null;
        $this->container['nfs'] = isset($data['nfs']) ? $data['nfs'] : null;
        $this->container['persistent_volume_reclaim_policy'] = isset($data['persistent_volume_reclaim_policy']) ? $data['persistent_volume_reclaim_policy'] : null;
        $this->container['photon_persistent_disk'] = isset($data['photon_persistent_disk']) ? $data['photon_persistent_disk'] : null;
        $this->container['portworx_volume'] = isset($data['portworx_volume']) ? $data['portworx_volume'] : null;
        $this->container['quobyte'] = isset($data['quobyte']) ? $data['quobyte'] : null;
        $this->container['rbd'] = isset($data['rbd']) ? $data['rbd'] : null;
        $this->container['scale_io'] = isset($data['scale_io']) ? $data['scale_io'] : null;
        $this->container['storage_class_name'] = isset($data['storage_class_name']) ? $data['storage_class_name'] : null;
        $this->container['storageos'] = isset($data['storageos']) ? $data['storageos'] : null;
        $this->container['vsphere_volume'] = isset($data['vsphere_volume']) ? $data['vsphere_volume'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        return true;
    }


    /**
     * Gets access_modes
     *
     * @return string[]
     */
    public function getAccessModes()
    {
        return $this->container['access_modes'];
    }

    /**
     * Sets access_modes
     *
     * @param string[] $access_modes AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
     *
     * @return $this
     */
    public function setAccessModes($access_modes)
    {
        $this->container['access_modes'] = $access_modes;

        return $this;
    }

    /**
     * Gets aws_elastic_block_store
     *
     * @return \CBSi\Kubernetes\Model\V1AWSElasticBlockStoreVolumeSource
     */
    public function getAwsElasticBlockStore()
    {
        return $this->container['aws_elastic_block_store'];
    }

    /**
     * Sets aws_elastic_block_store
     *
     * @param \CBSi\Kubernetes\Model\V1AWSElasticBlockStoreVolumeSource $aws_elastic_block_store AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
     *
     * @return $this
     */
    public function setAwsElasticBlockStore($aws_elastic_block_store)
    {
        $this->container['aws_elastic_block_store'] = $aws_elastic_block_store;

        return $this;
    }

    /**
     * Gets azure_disk
     *
     * @return \CBSi\Kubernetes\Model\V1AzureDiskVolumeSource
     */
    public function getAzureDisk()
    {
        return $this->container['azure_disk'];
    }

    /**
     * Sets azure_disk
     *
     * @param \CBSi\Kubernetes\Model\V1AzureDiskVolumeSource $azure_disk AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
     *
     * @return $this
     */
    public function setAzureDisk($azure_disk)
    {
        $this->container['azure_disk'] = $azure_disk;

        return $this;
    }

    /**
     * Gets azure_file
     *
     * @return \CBSi\Kubernetes\Model\V1AzureFileVolumeSource
     */
    public function getAzureFile()
    {
        return $this->container['azure_file'];
    }

    /**
     * Sets azure_file
     *
     * @param \CBSi\Kubernetes\Model\V1AzureFileVolumeSource $azure_file AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
     *
     * @return $this
     */
    public function setAzureFile($azure_file)
    {
        $this->container['azure_file'] = $azure_file;

        return $this;
    }

    /**
     * Gets capacity
     *
     * @return map[string,string]
     */
    public function getCapacity()
    {
        return $this->container['capacity'];
    }

    /**
     * Sets capacity
     *
     * @param map[string,string] $capacity A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
     *
     * @return $this
     */
    public function setCapacity($capacity)
    {
        $this->container['capacity'] = $capacity;

        return $this;
    }

    /**
     * Gets cephfs
     *
     * @return \CBSi\Kubernetes\Model\V1CephFSVolumeSource
     */
    public function getCephfs()
    {
        return $this->container['cephfs'];
    }

    /**
     * Sets cephfs
     *
     * @param \CBSi\Kubernetes\Model\V1CephFSVolumeSource $cephfs CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
     *
     * @return $this
     */
    public function setCephfs($cephfs)
    {
        $this->container['cephfs'] = $cephfs;

        return $this;
    }

    /**
     * Gets cinder
     *
     * @return \CBSi\Kubernetes\Model\V1CinderVolumeSource
     */
    public function getCinder()
    {
        return $this->container['cinder'];
    }

    /**
     * Sets cinder
     *
     * @param \CBSi\Kubernetes\Model\V1CinderVolumeSource $cinder Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
     *
     * @return $this
     */
    public function setCinder($cinder)
    {
        $this->container['cinder'] = $cinder;

        return $this;
    }

    /**
     * Gets claim_ref
     *
     * @return \CBSi\Kubernetes\Model\V1ObjectReference
     */
    public function getClaimRef()
    {
        return $this->container['claim_ref'];
    }

    /**
     * Sets claim_ref
     *
     * @param \CBSi\Kubernetes\Model\V1ObjectReference $claim_ref ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
     *
     * @return $this
     */
    public function setClaimRef($claim_ref)
    {
        $this->container['claim_ref'] = $claim_ref;

        return $this;
    }

    /**
     * Gets fc
     *
     * @return \CBSi\Kubernetes\Model\V1FCVolumeSource
     */
    public function getFc()
    {
        return $this->container['fc'];
    }

    /**
     * Sets fc
     *
     * @param \CBSi\Kubernetes\Model\V1FCVolumeSource $fc FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
     *
     * @return $this
     */
    public function setFc($fc)
    {
        $this->container['fc'] = $fc;

        return $this;
    }

    /**
     * Gets flex_volume
     *
     * @return \CBSi\Kubernetes\Model\V1FlexVolumeSource
     */
    public function getFlexVolume()
    {
        return $this->container['flex_volume'];
    }

    /**
     * Sets flex_volume
     *
     * @param \CBSi\Kubernetes\Model\V1FlexVolumeSource $flex_volume FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
     *
     * @return $this
     */
    public function setFlexVolume($flex_volume)
    {
        $this->container['flex_volume'] = $flex_volume;

        return $this;
    }

    /**
     * Gets flocker
     *
     * @return \CBSi\Kubernetes\Model\V1FlockerVolumeSource
     */
    public function getFlocker()
    {
        return $this->container['flocker'];
    }

    /**
     * Sets flocker
     *
     * @param \CBSi\Kubernetes\Model\V1FlockerVolumeSource $flocker Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
     *
     * @return $this
     */
    public function setFlocker($flocker)
    {
        $this->container['flocker'] = $flocker;

        return $this;
    }

    /**
     * Gets gce_persistent_disk
     *
     * @return \CBSi\Kubernetes\Model\V1GCEPersistentDiskVolumeSource
     */
    public function getGcePersistentDisk()
    {
        return $this->container['gce_persistent_disk'];
    }

    /**
     * Sets gce_persistent_disk
     *
     * @param \CBSi\Kubernetes\Model\V1GCEPersistentDiskVolumeSource $gce_persistent_disk GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
     *
     * @return $this
     */
    public function setGcePersistentDisk($gce_persistent_disk)
    {
        $this->container['gce_persistent_disk'] = $gce_persistent_disk;

        return $this;
    }

    /**
     * Gets glusterfs
     *
     * @return \CBSi\Kubernetes\Model\V1GlusterfsVolumeSource
     */
    public function getGlusterfs()
    {
        return $this->container['glusterfs'];
    }

    /**
     * Sets glusterfs
     *
     * @param \CBSi\Kubernetes\Model\V1GlusterfsVolumeSource $glusterfs Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
     *
     * @return $this
     */
    public function setGlusterfs($glusterfs)
    {
        $this->container['glusterfs'] = $glusterfs;

        return $this;
    }

    /**
     * Gets host_path
     *
     * @return \CBSi\Kubernetes\Model\V1HostPathVolumeSource
     */
    public function getHostPath()
    {
        return $this->container['host_path'];
    }

    /**
     * Sets host_path
     *
     * @param \CBSi\Kubernetes\Model\V1HostPathVolumeSource $host_path HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
     *
     * @return $this
     */
    public function setHostPath($host_path)
    {
        $this->container['host_path'] = $host_path;

        return $this;
    }

    /**
     * Gets iscsi
     *
     * @return \CBSi\Kubernetes\Model\V1ISCSIVolumeSource
     */
    public function getIscsi()
    {
        return $this->container['iscsi'];
    }

    /**
     * Sets iscsi
     *
     * @param \CBSi\Kubernetes\Model\V1ISCSIVolumeSource $iscsi ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
     *
     * @return $this
     */
    public function setIscsi($iscsi)
    {
        $this->container['iscsi'] = $iscsi;

        return $this;
    }

    /**
     * Gets local
     *
     * @return \CBSi\Kubernetes\Model\V1LocalVolumeSource
     */
    public function getLocal()
    {
        return $this->container['local'];
    }

    /**
     * Sets local
     *
     * @param \CBSi\Kubernetes\Model\V1LocalVolumeSource $local Local represents directly-attached storage with node affinity
     *
     * @return $this
     */
    public function setLocal($local)
    {
        $this->container['local'] = $local;

        return $this;
    }

    /**
     * Gets nfs
     *
     * @return \CBSi\Kubernetes\Model\V1NFSVolumeSource
     */
    public function getNfs()
    {
        return $this->container['nfs'];
    }

    /**
     * Sets nfs
     *
     * @param \CBSi\Kubernetes\Model\V1NFSVolumeSource $nfs NFS represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
     *
     * @return $this
     */
    public function setNfs($nfs)
    {
        $this->container['nfs'] = $nfs;

        return $this;
    }

    /**
     * Gets persistent_volume_reclaim_policy
     *
     * @return string
     */
    public function getPersistentVolumeReclaimPolicy()
    {
        return $this->container['persistent_volume_reclaim_policy'];
    }

    /**
     * Sets persistent_volume_reclaim_policy
     *
     * @param string $persistent_volume_reclaim_policy What happens to a persistent volume when released from its claim. Valid options are Retain (default) and Recycle. Recycling must be supported by the volume plugin underlying this persistent volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
     *
     * @return $this
     */
    public function setPersistentVolumeReclaimPolicy($persistent_volume_reclaim_policy)
    {
        $this->container['persistent_volume_reclaim_policy'] = $persistent_volume_reclaim_policy;

        return $this;
    }

    /**
     * Gets photon_persistent_disk
     *
     * @return \CBSi\Kubernetes\Model\V1PhotonPersistentDiskVolumeSource
     */
    public function getPhotonPersistentDisk()
    {
        return $this->container['photon_persistent_disk'];
    }

    /**
     * Sets photon_persistent_disk
     *
     * @param \CBSi\Kubernetes\Model\V1PhotonPersistentDiskVolumeSource $photon_persistent_disk PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
     *
     * @return $this
     */
    public function setPhotonPersistentDisk($photon_persistent_disk)
    {
        $this->container['photon_persistent_disk'] = $photon_persistent_disk;

        return $this;
    }

    /**
     * Gets portworx_volume
     *
     * @return \CBSi\Kubernetes\Model\V1PortworxVolumeSource
     */
    public function getPortworxVolume()
    {
        return $this->container['portworx_volume'];
    }

    /**
     * Sets portworx_volume
     *
     * @param \CBSi\Kubernetes\Model\V1PortworxVolumeSource $portworx_volume PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
     *
     * @return $this
     */
    public function setPortworxVolume($portworx_volume)
    {
        $this->container['portworx_volume'] = $portworx_volume;

        return $this;
    }

    /**
     * Gets quobyte
     *
     * @return \CBSi\Kubernetes\Model\V1QuobyteVolumeSource
     */
    public function getQuobyte()
    {
        return $this->container['quobyte'];
    }

    /**
     * Sets quobyte
     *
     * @param \CBSi\Kubernetes\Model\V1QuobyteVolumeSource $quobyte Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
     *
     * @return $this
     */
    public function setQuobyte($quobyte)
    {
        $this->container['quobyte'] = $quobyte;

        return $this;
    }

    /**
     * Gets rbd
     *
     * @return \CBSi\Kubernetes\Model\V1RBDVolumeSource
     */
    public function getRbd()
    {
        return $this->container['rbd'];
    }

    /**
     * Sets rbd
     *
     * @param \CBSi\Kubernetes\Model\V1RBDVolumeSource $rbd RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
     *
     * @return $this
     */
    public function setRbd($rbd)
    {
        $this->container['rbd'] = $rbd;

        return $this;
    }

    /**
     * Gets scale_io
     *
     * @return \CBSi\Kubernetes\Model\V1ScaleIOVolumeSource
     */
    public function getScaleIo()
    {
        return $this->container['scale_io'];
    }

    /**
     * Sets scale_io
     *
     * @param \CBSi\Kubernetes\Model\V1ScaleIOVolumeSource $scale_io ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
     *
     * @return $this
     */
    public function setScaleIo($scale_io)
    {
        $this->container['scale_io'] = $scale_io;

        return $this;
    }

    /**
     * Gets storage_class_name
     *
     * @return string
     */
    public function getStorageClassName()
    {
        return $this->container['storage_class_name'];
    }

    /**
     * Sets storage_class_name
     *
     * @param string $storage_class_name Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.
     *
     * @return $this
     */
    public function setStorageClassName($storage_class_name)
    {
        $this->container['storage_class_name'] = $storage_class_name;

        return $this;
    }

    /**
     * Gets storageos
     *
     * @return \CBSi\Kubernetes\Model\V1StorageOSPersistentVolumeSource
     */
    public function getStorageos()
    {
        return $this->container['storageos'];
    }

    /**
     * Sets storageos
     *
     * @param \CBSi\Kubernetes\Model\V1StorageOSPersistentVolumeSource $storageos StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md
     *
     * @return $this
     */
    public function setStorageos($storageos)
    {
        $this->container['storageos'] = $storageos;

        return $this;
    }

    /**
     * Gets vsphere_volume
     *
     * @return \CBSi\Kubernetes\Model\V1VsphereVirtualDiskVolumeSource
     */
    public function getVsphereVolume()
    {
        return $this->container['vsphere_volume'];
    }

    /**
     * Sets vsphere_volume
     *
     * @param \CBSi\Kubernetes\Model\V1VsphereVirtualDiskVolumeSource $vsphere_volume VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
     *
     * @return $this
     */
    public function setVsphereVolume($vsphere_volume)
    {
        $this->container['vsphere_volume'] = $vsphere_volume;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


